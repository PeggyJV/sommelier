package types

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"

	"github.com/stretchr/testify/suite"
)

type ABITestSuite struct {
	suite.Suite

	logicContract common.Address
	tokenContract common.Address
	tokenA        common.Address
	tokenB        common.Address
	to            common.Address
}

func (suite *ABITestSuite) SetupTest() {
	suite.tokenA = common.HexToAddress("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48") // USDC
	suite.tokenB = common.HexToAddress("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2") // WETH

	suite.to = common.HexToAddress("0x0c731Fb0D03211DD32A456370AD2ec3fFad46520")
	suite.logicContract = common.HexToAddress("0xf784709d2317D872237C4bC22f867d1BAe2913AB")
	suite.tokenContract = common.HexToAddress("0xb4e16d0168e52d35cacd2c6185b44281ec28c9dc") // USDC-ETH LP
}

func (suite *ABITestSuite) makeTestRedeemLiquidityETH() *RedeemLiquidityETH {
	return NewRedeemLiquidityETHCall(suite.tokenA.String(), 2000000000000, 0, 0, suite.to.String(), 4766922941000)
}

func (suite *ABITestSuite) TestRedeemLiquidityETH() {
	// hash derived from javascript testing environment
	// ask @jackzampolin @jkilpatr or @jehan about the method here
	expHash := "0x0f77f6b2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000001d1a94a2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c731fb0d03211dd32a456370ad2ec3ffad4652000000000000000000000000000000000000000000000000000000455e2bfa248"[2:]

	testCases := []struct {
		msg     string
		redeem  *RedeemLiquidityETH
		expPass bool
	}{
		{
			"valid",
			NewRedeemLiquidityETHCall(suite.tokenA.String(), 2000000000000, 0, 0, suite.to.String(), 4766922941000),
			true,
		},
	}

	for _, tc := range testCases {
		abiHash, err := tc.redeem.GetEncodedCall()
		if tc.expPass {
			suite.NoError(err, tc.msg)
			suite.Equal(expHash, common.Bytes2Hex(abiHash))
		} else {
			suite.Error(err, tc.msg)
		}
	}
}

func (suite *ABITestSuite) TestRedeemLiquidity() {
	// hash derived from javascript testing environment
	// ask @jackzampolin @jkilpatr or @jehan about the method here
	expHash := "0x0f77f6b2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000001d1a94a2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c731fb0d03211dd32a456370ad2ec3ffad4652000000000000000000000000000000000000000000000000000000455e2bfa248"[2:]

	testCases := []struct {
		msg     string
		redeem  *RedeemLiquidity
		expPass bool
	}{
		{
			"valid",
			NewRedeemLiquidityCall(suite.tokenA.String(), suite.tokenB.String(), 2000000000000, 0, 0, suite.to.String(), 4766922941000),
			true,
		},
	}

	for _, tc := range testCases {
		abiHash, err := tc.redeem.GetEncodedCall()
		if tc.expPass {
			suite.NoError(err, tc.msg)
			suite.Equal(expHash, common.Bytes2Hex(abiHash))
		} else {
			suite.Error(err, tc.msg)
		}
	}
}

func (suite *ABITestSuite) TestSimpleBatchRedeem() {
	// hash derived from javascript testing environment
	// ask @jackzampolin @jkilpatr or @jehan about the method here
	expHash := "0x6f1de7e700000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000100000000000000000000000000f784709d2317d872237c4bc22f867d1bae2913ab000000000000000000000000b4e16d0168e52d35cacd2c6185b44281ec28c9dc0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000001d1a94a2000000000000000000000000000000000000000000000000000000001d1a94a2000000000000000000000000000000000000000000000000000000001d1a94a2000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000000c40f77f6b2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000001d1a94a2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c731fb0d03211dd32a456370ad2ec3ffad4652000000000000000000000000000000000000000000000000000000455e2bfa2480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c40f77f6b2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000001d1a94a2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c731fb0d03211dd32a456370ad2ec3ffad4652000000000000000000000000000000000000000000000000000000455e2bfa2480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c40f77f6b2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000001d1a94a2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c731fb0d03211dd32a456370ad2ec3ffad4652000000000000000000000000000000000000000000000000000000455e2bfa24800000000000000000000000000000000000000000000000000000000"[2:]

	testCases := []struct {
		msg     string
		redeem  SimpleLogicBatch
		expPass bool
	}{
		{
			"valid",
			SimpleLogicBatch{
				Amounts:       []*big.Int{big.NewInt(2000000000000), big.NewInt(2000000000000), big.NewInt(2000000000000)},
				Payloads:      []Payload{suite.makeTestRedeemLiquidityETH(), suite.makeTestRedeemLiquidityETH(), suite.makeTestRedeemLiquidityETH()},
				LogicContract: suite.logicContract,
				TokenContract: suite.tokenContract,
			},
			true,
		},
	}

	for _, tc := range testCases {
		abiHash, err := tc.redeem.GetEncodedCall()
		if tc.expPass {
			suite.NoError(err, tc.msg)
			suite.Equal(expHash, common.Bytes2Hex(abiHash))
		} else {
			suite.Error(err, tc.msg)
		}
	}
}
